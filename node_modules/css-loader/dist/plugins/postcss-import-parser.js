"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _postcssValueParser = _interopRequireDefault(require("postcss-value-parser"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

<<<<<<< HEAD
function parseNode(atRule, key, options) {
=======
function parseNode(atRule, key) {
>>>>>>> 59200b616be23b58448c0052ee601131639d6e3f
  // Convert only top-level @import
  if (atRule.parent.type !== "root") {
    return;
  }

  if (atRule.raws && atRule.raws.afterName && atRule.raws.afterName.trim().length > 0) {
    const lastCommentIndex = atRule.raws.afterName.lastIndexOf("/*");
    const matched = atRule.raws.afterName.slice(lastCommentIndex).match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);

    if (matched && matched[2] === "true") {
      return;
    }
  }

  const prevNode = atRule.prev();

  if (prevNode && prevNode.type === "comment") {
    const matched = prevNode.text.match(_utils.WEBPACK_IGNORE_COMMENT_REGEXP);

    if (matched && matched[2] === "true") {
      return;
    }
  } // Nodes do not exists - `@import url('http://') :root {}`


  if (atRule.nodes) {
    const error = new Error("It looks like you didn't end your @import statement correctly. Child nodes are attached to it.");
    error.node = atRule;
    throw error;
  }

<<<<<<< HEAD
  const rawParams = atRule.raws && atRule.raws[key] && typeof atRule.raws[key].raw !== "undefined" ? atRule.raws[key].raw : atRule[key];
  const {
    nodes: paramsNodes
  } = (0, _postcssValueParser.default)(rawParams); // No nodes - `@import ;`
=======
  const {
    nodes: paramsNodes
  } = (0, _postcssValueParser.default)(atRule[key]); // No nodes - `@import ;`
>>>>>>> 59200b616be23b58448c0052ee601131639d6e3f
  // Invalid type - `@import foo-bar;`

  if (paramsNodes.length === 0 || paramsNodes[0].type !== "string" && paramsNodes[0].type !== "function") {
    const error = new Error(`Unable to find uri in "${atRule.toString()}"`);
    error.node = atRule;
    throw error;
  }

  let isStringValue;
  let url;

  if (paramsNodes[0].type === "string") {
    isStringValue = true;
    url = paramsNodes[0].value;
  } else {
    // Invalid function - `@import nourl(test.css);`
    if (paramsNodes[0].value.toLowerCase() !== "url") {
      const error = new Error(`Unable to find uri in "${atRule.toString()}"`);
      error.node = atRule;
      throw error;
    }

    isStringValue = paramsNodes[0].nodes.length !== 0 && paramsNodes[0].nodes[0].type === "string";
    url = isStringValue ? paramsNodes[0].nodes[0].value : _postcssValueParser.default.stringify(paramsNodes[0].nodes);
  }

  url = (0, _utils.normalizeUrl)(url, isStringValue);
<<<<<<< HEAD
  const {
    requestable,
    needResolve
  } = (0, _utils.isURLRequestable)(url, options);
  let prefix;

  if (requestable && needResolve) {
=======
  const isRequestable = (0, _utils.isUrlRequestable)(url);
  let prefix;

  if (isRequestable) {
>>>>>>> 59200b616be23b58448c0052ee601131639d6e3f
    const queryParts = url.split("!");

    if (queryParts.length > 1) {
      url = queryParts.pop();
      prefix = queryParts.join("!");
    }
  } // Empty url - `@import "";` or `@import url();`


  if (url.trim().length === 0) {
    const error = new Error(`Unable to find uri in "${atRule.toString()}"`);
    error.node = atRule;
    throw error;
  }

<<<<<<< HEAD
  const additionalNodes = paramsNodes.slice(1);
  let supports;
  let layer;
  let media;

  if (additionalNodes.length > 0) {
    let nodes = [];

    for (const node of additionalNodes) {
      nodes.push(node);
      const isLayerFunction = node.type === "function" && node.value.toLowerCase() === "layer";
      const isLayerWord = node.type === "word" && node.value.toLowerCase() === "layer";

      if (isLayerFunction || isLayerWord) {
        if (isLayerFunction) {
          nodes.splice(nodes.length - 1, 1, ...node.nodes);
        } else {
          nodes.splice(nodes.length - 1, 1, {
            type: "string",
            value: "",
            unclosed: false
          });
        }

        layer = _postcssValueParser.default.stringify(nodes).trim().toLowerCase();
        nodes = [];
      } else if (node.type === "function" && node.value.toLowerCase() === "supports") {
        nodes.splice(nodes.length - 1, 1, ...node.nodes);
        supports = _postcssValueParser.default.stringify(nodes).trim().toLowerCase();
        nodes = [];
      }
    }

    if (nodes.length > 0) {
      media = _postcssValueParser.default.stringify(nodes).trim().toLowerCase();
    }
=======
  const mediaNodes = paramsNodes.slice(1);
  let media;

  if (mediaNodes.length > 0) {
    media = _postcssValueParser.default.stringify(mediaNodes).trim().toLowerCase();
>>>>>>> 59200b616be23b58448c0052ee601131639d6e3f
  } // eslint-disable-next-line consistent-return


  return {
    atRule,
    prefix,
    url,
<<<<<<< HEAD
    layer,
    supports,
    media,
    requestable,
    needResolve
=======
    media,
    isRequestable
>>>>>>> 59200b616be23b58448c0052ee601131639d6e3f
  };
}

const plugin = (options = {}) => {
  return {
    postcssPlugin: "postcss-import-parser",

    prepare(result) {
      const parsedAtRules = [];
      return {
        AtRule: {
          import(atRule) {
<<<<<<< HEAD
            if (options.isCSSStyleSheet) {
              options.loaderContext.emitError(new Error(atRule.error("'@import' rules are not allowed here and will not be processed").message));
              return;
            }

            const {
              isSupportDataURL,
              isSupportAbsoluteURL
            } = options;
            let parsedAtRule;

            try {
              parsedAtRule = parseNode(atRule, "params", {
                isSupportAbsoluteURL,
                isSupportDataURL
              });
=======
            let parsedAtRule;

            try {
              parsedAtRule = parseNode(atRule, "params", result);
>>>>>>> 59200b616be23b58448c0052ee601131639d6e3f
            } catch (error) {
              result.warn(error.message, {
                node: error.node
              });
            }

            if (!parsedAtRule) {
              return;
            }

            parsedAtRules.push(parsedAtRule);
          }

        },

        async OnceExit() {
          if (parsedAtRules.length === 0) {
            return;
          }

<<<<<<< HEAD
          const {
            loaderContext
          } = options;
          const resolver = loaderContext.getResolve({
            dependencyType: "css",
            conditionNames: ["style"],
            mainFields: ["css", "style", "main", "..."],
            mainFiles: ["index", "..."],
            extensions: [".css", "..."],
            preferRelative: true
          });
          const resolvedAtRules = await Promise.all(parsedAtRules.map(async parsedAtRule => {
            const {
              atRule,
              requestable,
              needResolve,
              prefix,
              url,
              layer,
              supports,
=======
          const resolvedAtRules = await Promise.all(parsedAtRules.map(async parsedAtRule => {
            const {
              atRule,
              isRequestable,
              prefix,
              url,
>>>>>>> 59200b616be23b58448c0052ee601131639d6e3f
              media
            } = parsedAtRule;

            if (options.filter) {
<<<<<<< HEAD
              const needKeep = await options.filter(url, media, loaderContext.resourcePath, supports, layer);
=======
              const needKeep = await options.filter(url, media);
>>>>>>> 59200b616be23b58448c0052ee601131639d6e3f

              if (!needKeep) {
                return;
              }
            }

<<<<<<< HEAD
            if (needResolve) {
              const request = (0, _utils.requestify)(url, loaderContext.rootContext);
              const resolvedUrl = await (0, _utils.resolveRequests)(resolver, loaderContext.context, [...new Set([request, url])]);
=======
            if (isRequestable) {
              const request = (0, _utils.requestify)(url, options.rootContext);
              const {
                resolver,
                context
              } = options;
              const resolvedUrl = await (0, _utils.resolveRequests)(resolver, context, [...new Set([request, url])]);
>>>>>>> 59200b616be23b58448c0052ee601131639d6e3f

              if (!resolvedUrl) {
                return;
              }

<<<<<<< HEAD
              if (resolvedUrl === loaderContext.resourcePath) {
                atRule.remove();
                return;
              }

=======
>>>>>>> 59200b616be23b58448c0052ee601131639d6e3f
              atRule.remove(); // eslint-disable-next-line consistent-return

              return {
                url: resolvedUrl,
<<<<<<< HEAD
                layer,
                supports,
                media,
                prefix,
                requestable
=======
                media,
                prefix,
                isRequestable
>>>>>>> 59200b616be23b58448c0052ee601131639d6e3f
              };
            }

            atRule.remove(); // eslint-disable-next-line consistent-return

            return {
              url,
<<<<<<< HEAD
              layer,
              supports,
              media,
              prefix,
              requestable
=======
              media,
              prefix,
              isRequestable
>>>>>>> 59200b616be23b58448c0052ee601131639d6e3f
            };
          }));
          const urlToNameMap = new Map();

          for (let index = 0; index <= resolvedAtRules.length - 1; index++) {
            const resolvedAtRule = resolvedAtRules[index];

            if (!resolvedAtRule) {
              // eslint-disable-next-line no-continue
              continue;
            }

            const {
              url,
<<<<<<< HEAD
              requestable,
              layer,
              supports,
              media
            } = resolvedAtRule;

            if (!requestable) {
              options.api.push({
                url,
                layer,
                supports,
=======
              isRequestable,
              media
            } = resolvedAtRule;

            if (!isRequestable) {
              options.api.push({
                url,
>>>>>>> 59200b616be23b58448c0052ee601131639d6e3f
                media,
                index
              }); // eslint-disable-next-line no-continue

              continue;
            }

            const {
              prefix
            } = resolvedAtRule;
            const newUrl = prefix ? `${prefix}!${url}` : url;
            let importName = urlToNameMap.get(newUrl);

            if (!importName) {
              importName = `___CSS_LOADER_AT_RULE_IMPORT_${urlToNameMap.size}___`;
              urlToNameMap.set(newUrl, importName);
              options.imports.push({
<<<<<<< HEAD
                type: "rule_import",
=======
>>>>>>> 59200b616be23b58448c0052ee601131639d6e3f
                importName,
                url: options.urlHandler(newUrl),
                index
              });
            }

            options.api.push({
              importName,
<<<<<<< HEAD
              layer,
              supports,
=======
>>>>>>> 59200b616be23b58448c0052ee601131639d6e3f
              media,
              index
            });
          }
        }

      };
    }

  };
};

plugin.postcss = true;
var _default = plugin;
exports.default = _default;